/**
 * @fileoverview Abstract base class for every shape in the Otto parametric 2D design system.
 *
 * Shape uses the Template Method Pattern: it defines the full algorithm for how a shape
 * participates in the system (resolving parameter bindings, serializing, hit-testing) while
 * leaving the geometry-specific steps (building the path, cloning, rendering) to concrete
 * subclasses.  Every shape type in Otto -- Circle, Rectangle, Gear, PathShape, etc. --
 * extends this class and implements the abstract methods listed below.
 *
 * Key responsibilities of Shape:
 *   - Owns the unique shape id, its registered type string, and a legacy position object.
 *   - Maintains the bindings map: the set of live connections between this shape's numeric
 *     properties and user-created parameter sliders.  When a property is bound, its value
 *     at render time is driven by the parameter rather than by the literal value stored on
 *     the shape.
 *   - Implements resolve(), the core Template Method.  resolve() is called once per frame
 *     by the renderer.  It clones the shape, walks every bindable property, and replaces
 *     any bound property with the current value from its parameter via bindingResolver.
 *     The returned copy is the "resolved" shape that is actually rendered and hit-tested.
 *   - Implements toJSON() / fromJSON() for persistence.  toJSON() serialises the id, type,
 *     position, every active binding (via Binding.toJSON()), and every bindable property
 *     that does NOT currently have a binding (i.e. literal values).  The static fromJSON()
 *     deliberately throws: deserialization must go through ShapeRegistry.fromJSON() so that
 *     bindings can be reconstructed via BindingRegistry.
 *
 * @module models/shapes/Shape
 */

/**
 * Abstract base class for all Otto shapes.
 *
 * This class cannot be instantiated directly.  It enforces that every concrete
 * shape subclass provides implementations of the abstract methods:
 *   - {@link Shape#getBindableProperties}
 *   - {@link Shape#getBounds}
 *   - {@link Shape#containsPoint}
 *   - {@link Shape#render}
 *   - {@link Shape#clone}
 *
 * @abstract
 * @class
 */
export class Shape {
    /**
     * Construct a Shape.  Intended to be called only via super() from a concrete subclass.
     *
     * Throws immediately if called directly on Shape itself (abstract guard).  This is the
     * JavaScript equivalent of marking the class abstract: there is no language keyword for
     * it, so the constructor performs a runtime check.
     *
     * @param {string} id       - A unique, human-readable identifier for this shape instance
     *                             (e.g. "Circle 3").  Generated by {@link ShapeRegistry.generateId}
     *                             at creation time and preserved across save/load cycles.
     * @param {string} type     - The registered type key for this shape (e.g. 'circle',
     *                             'rectangle').  Must match the key used when the shape was
     *                             registered with {@link ShapeRegistry.register}.  Used as the
     *                             discriminator during deserialization.
     * @param {Object} [position={x:0, y:0}] - Legacy canvas-space position object.  Many
     *                             shapes define their own geometry origin via bindable
     *                             properties (centerX/centerY or x/y), so this field is not
     *                             used for geometry calculations.  It is preserved for
     *                             backward compatibility and serialized in toJSON().
     */
    constructor(id, type, position = { x: 0, y: 0 }) {
        if (this.constructor === Shape) {
            throw new Error('Shape is an abstract class and cannot be instantiated directly');
        }
        /** @type {string} Unique, human-readable identifier (e.g. "Circle 3"). */
        this.id = id;
        /** @type {string} Registered type key matching the ShapeRegistry entry (e.g. 'circle'). */
        this.type = type;
        /** @type {{x: number, y: number}} Legacy position; shallow-copied to avoid shared references. */
        this.position = { ...position };
        /**
         * @type {Object.<string, import('../Binding.js').Binding>}
         * Map from bindable property name to its active Binding object.
         * An entry exists only for properties that are currently driven by a parameter.
         * Properties absent from this map retain their literal (hard-coded) values.
         */
        this.bindings = {}; // Map of property name to Binding object
    }
    
    /**
     * Return the list of property names on this shape that can be driven by parameter
     * bindings.  This is the declaration layer of the parametric system: every property
     * name returned here becomes eligible to appear in the Properties Panel as a bindable
     * field, and will be iterated by {@link Shape#resolve} and {@link Shape#toJSON}.
     *
     * WHY it exists: not every property on a shape is numeric or meaningful to expose to
     * the user as a slider.  By requiring each subclass to explicitly enumerate its
     * bindable set, the system avoids introspecting the object and keeps the binding
     * contract explicit and self-documenting.
     *
     * This method MUST be overridden by every concrete subclass.  The base implementation
     * throws to catch any subclass that forgets.
     *
     * @abstract
     * @returns {string[]} Ordered array of property names (e.g. ['centerX', 'centerY', 'radius']).
     * @throws {Error} Always, if called on the base class directly.
     */
    getBindableProperties() {
        throw new Error('getBindableProperties() must be implemented by subclass');
    }

    /**
     * Template Method -- produce a fully-resolved copy of this shape with all parameter
     * bindings evaluated to their current numeric values.
     *
     * This is the central mechanism by which Otto shapes become parametric.  The renderer
     * calls resolve() once per frame for every shape in the scene.  The original shape
     * (stored in ShapeStore) is never mutated; instead a new instance is created, its
     * bound properties overwritten with the live parameter values, and the resolved copy
     * is what gets rendered, hit-tested, and used for bounding-box calculations.
     *
     * Algorithm (the "template"):
     *   1. Clone this shape via {@link Shape#clone} -- produces an identical copy including
     *      all bindings.
     *   2. Walk every property name returned by {@link Shape#getBindableProperties}.
     *   3. If the property has an active Binding AND a bindingResolver is available,
     *      evaluate the binding through bindingResolver.resolveValue() and write the
     *      resulting number onto the cloned shape.
     *   4. Otherwise, copy the literal value from the original shape (a no-op in practice
     *      because clone() already copied it, but included for clarity).
     *   5. Return the resolved clone.
     *
     * @param {Object} parameterStore  - The global store of user-defined parameters.
     *                                   Passed for context but the actual value lookup is
     *                                   delegated to bindingResolver.
     * @param {Object} bindingResolver - The resolver that knows how to evaluate a Binding
     *                                   object into a concrete number.  May be null during
     *                                   unit tests or initialisation; in that case bound
     *                                   properties retain their last-set literal values.
     * @returns {Shape} A new Shape instance with all bindings replaced by their current
     *                  numeric values.  Safe to render and mutate without affecting the
     *                  original.
     */
    resolve(parameterStore, bindingResolver) {
        // Create a copy of this shape
        const resolved = this.clone();

        // Resolve each binding
        this.getBindableProperties().forEach(property => {
            const binding = this.bindings[property];
            if (binding && bindingResolver) {
                const value = bindingResolver.resolveValue(binding);
                resolved[property] = value;
            } else if (this[property] !== undefined) {
                // Use existing value if no binding
                resolved[property] = this[property];
            }
        });

        if (typeof this.rotation === 'number') {
            resolved.rotation = this.rotation;
        }
        
        return resolved;
    }
    
    /**
     * Compute the axis-aligned bounding box (AABB) that tightly encloses this shape.
     *
     * The bounding box is used by the renderer for culling (skipping shapes that are
     * entirely off-screen), by the selection system for quick rejection before running
     * the more expensive containsPoint test, and by the Properties Panel to display the
     * shape's current spatial extent.
     *
     * Most concrete shapes delegate to their geometry path:
     *   {@code const box = this.toGeometryPath().tightBoundingBox(); }
     * Shapes with analytically computable bounds (e.g. Donut) may compute them directly
     * for performance.
     *
     * @abstract
     * @returns {{x: number, y: number, width: number, height: number}}
     *          Top-left origin bounding rectangle in canvas coordinates.
     * @throws {Error} Always, if called on the base class directly.
     */
    getBounds() {
        throw new Error('getBounds() must be implemented by subclass');
    }

    /**
     * Determine whether the given canvas-space point lies inside (or on the stroke of)
     * this shape.  Used by the selection / drag system to decide whether a mouse click
     * or touch landed on this shape.
     *
     * The standard implementation pattern in concrete shapes is:
     *   1. Build the geometry path via toGeometryPath().
     *   2. Assign a module-level HIT_TEST_FILL (for closed/filled shapes) or
     *      HIT_TEST_STROKE (for open/line shapes) to the path.  These are opaque black
     *      fills/strokes whose sole purpose is to give styleContainsPoint a style to
     *      rasterise and sample.
     *   3. Call styleContainsPoint(path, point) which performs the actual pixel-level
     *      containment test.
     *
     * Donut overrides this pattern entirely with a direct distance calculation for speed.
     *
     * @abstract
     * @param {number} x - X coordinate in canvas space.
     * @param {number} y - Y coordinate in canvas space.
     * @returns {boolean} True if the point is inside or on the boundary of the shape.
     * @throws {Error} Always, if called on the base class directly.
     */
    containsPoint(x, y) {
        throw new Error('containsPoint() must be implemented by subclass');
    }

    /**
     * Draw this shape onto the given 2D canvas rendering context.
     *
     * Concrete subclasses typically build their geometry path via toGeometryPath(),
     * emit it onto the context with path.toCanvasPath(ctx), and then call ctx.stroke()
     * (and optionally ctx.fill()).  The CanvasRenderer is responsible for setting up
     * stroke/fill styles, selection highlights, and other visual decorations around
     * this call.
     *
     * @abstract
     * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the Otto canvas.
     * @throws {Error} Always, if called on the base class directly.
     */
    render(ctx) {
        throw new Error('render() must be implemented by subclass');
    }

    /**
     * Produce a deep copy of this shape, including all current property values AND all
     * active bindings.
     *
     * clone() is the workhorse of {@link Shape#resolve}: the Template Method clones first,
     * then overwrites bound properties on the copy.  It is also used whenever the
     * application needs to duplicate a shape (e.g. copy-paste).
     *
     * Implementation requirements for subclasses:
     *   - Construct a new instance of the same concrete class with identical property values.
     *   - Iterate getBindableProperties() and, for each property that has a binding on
     *     {@code this}, call setBinding() on the new instance to copy the reference.
     *     (Bindings themselves are lightweight descriptor objects and do not need deep
     *     copying here.)
     *
     * @abstract
     * @returns {Shape} A new Shape instance that is value-equal to this one.
     * @throws {Error} Always, if called on the base class directly.
     */
    clone() {
        throw new Error('clone() must be implemented by subclass');
    }
    
    /**
     * Attach a parameter Binding to one of this shape's bindable properties.
     *
     * After this call, the named property will no longer use its literal value at render
     * time.  Instead, {@link Shape#resolve} will evaluate the binding through the
     * bindingResolver and write the result onto the resolved copy.
     *
     * A validation guard prevents binding a property that the shape did not declare as
     * bindable.  This catches typos and misuse early -- for example, trying to bind
     * 'strokeWidth' on a Circle (which only exposes centerX, centerY, radius) will throw.
     *
     * @param {string} property  - The property name.  Must appear in the array returned by
     *                              {@link Shape#getBindableProperties}.
     * @param {import('../Binding.js').Binding} binding - The Binding descriptor that
     *                              connects this property to a user-defined parameter.
     * @throws {Error} If {@code property} is not in the shape's bindable set.
     */
    setBinding(property, binding) {
        if (!this.getBindableProperties().includes(property)) {
            throw new Error(`Property ${property} is not bindable for ${this.type}`);
        }
        this.bindings[property] = binding;
    }

    /**
     * Retrieve the active Binding for a property, or null if the property is currently
     * using its literal value.
     *
     * Used by the Properties Panel to render the "bound" indicator next to a slider when
     * a parameter is driving it, and by the binding editor to pre-populate the binding
     * configuration UI.
     *
     * @param {string} property - The property name to look up.
     * @returns {import('../Binding.js').Binding|null} The active Binding, or null.
     */
    getBinding(property) {
        return this.bindings[property] || null;
    }
    
    /**
     * Serialize this shape into a plain JSON-safe object suitable for saving to
     * localStorage or exporting as a .otto project file.
     *
     * Serialization strategy:
     *   - Always writes: id, type, position (the structural skeleton).
     *   - Bindings object: for every property that currently has an active Binding,
     *     serializes the Binding itself via Binding.toJSON().  The Binding JSON contains
     *     the parameter id, expression, min/max overrides, etc.
     *   - Literal values: for every bindable property that does NOT have a binding,
     *     writes the current numeric value directly into the JSON.  This means that at
     *     any point in time, exactly one of {binding, literal value} is stored per property.
     *
     * Some subclasses (e.g. Line, PathShape) override toJSON() to add properties that live
     * outside the bindable set (e.g. the points array on PathShape, which is set by the
     * drawing tool rather than by parameter sliders).
     *
     * @returns {Object} A plain object ready for JSON.stringify().
     */
    toJSON() {
        const json = {
            id: this.id,
            type: this.type,
            position: { ...this.position },
            bindings: {}
        };

        // Serialize bindings
        Object.keys(this.bindings).forEach(property => {
            json.bindings[property] = this.bindings[property].toJSON();
        });

        // Add shape-specific properties (to be extended by subclasses)
        this.getBindableProperties().forEach(property => {
            if (this[property] !== undefined && !this.bindings[property]) {
                json[property] = this[property];
            }
        });

        return json;
    }

    /**
     * Static factory for deserializing a Shape from JSON.
     *
     * Deliberately throws.  Deserialization MUST go through {@link ShapeRegistry.fromJSON}
     * instead, because ShapeRegistry is the only place that knows how to look up the
     * correct concrete class by the type discriminator AND how to reconstruct Binding
     * objects via BindingRegistry.createBindingFromJSON.  Calling Shape.fromJSON() directly
     * would produce an incomplete shape with no bindings restored.
     *
     * @param {Object} json - The serialized shape object.
     * @throws {Error} Always.  Directs the caller to ShapeRegistry.fromJSON().
     */
    static fromJSON(json) {
        throw new Error('Use ShapeRegistry.fromJSON() instead');
    }
}
